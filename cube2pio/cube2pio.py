import os
import argparse
from os.path import join
import shutil
from typing import List

def file_2_lines(path: str) -> List[str]:
    with open(path, "r") as f:
        lines = f.readlines()
    return lines

def lines_2_file(lines: List[str], save_path: str) -> None:
    with open(save_path, "w") as f:
        f.writelines(lines)

def line_insert_port(tag: str, content: List[str], insert: str) -> List[str]:
    lines = content
    lines_stripped = [line.strip() for line in content]
    i = lines_stripped.index(tag)
    lines.insert(i+1, insert + "\n")
    return lines

def line_extract(start: str, stop: str, content: List[str]) -> List[str]:
    lines_stripped = [line.strip() for line in content]
    i_start = lines_stripped.index(start)
    i_stop = lines_stripped.index(stop)
    return content[i_start+1:i_stop]

def port_init(pio_project_dir: str):
    main_path = join(pio_project_dir, "src")
    if not os.path.exists(join(main_path, "main.c")):
        content = """#include "port.h"
void port_setup(void){
}
void port_loop(void){
}"""
        with open(join(main_path, "main.c"), "w") as f:
            f.write(content)

def port_copy(cube_project_dir: str, pio_project_dir: str, lib_dir: str, use_freertos: bool):
    local_path = join(pio_project_dir, "lib", lib_dir)
    os.makedirs(local_path, exist_ok=True)
    src_path = join(cube_project_dir, "Core", "Src")
    inc_path = join(cube_project_dir, "Core", "Inc")
    src_files = os.listdir(src_path)
    inc_files = os.listdir(inc_path)

    for s_f in src_files:
        shutil.copy(join(src_path, s_f), join(local_path, s_f))
        if use_freertos and "_it.c" in s_f:
            with open(join(local_path, s_f), "r+") as f:
                lines = f.readlines()
                f.seek(0)
                for i, line in enumerate(lines):
                    if any(x in line for x in ["void SVC_Handler(void)", "void PendSV_Handler(void)", "void SysTick_Handler(void)"]):
                        if "__weak" in line:
                            continue
                        lines[i] = "__weak " + line
                f.write("".join(lines))
                f.truncate()

    for i_f in inc_files:
        shutil.copy(join(inc_path, i_f), join(local_path, i_f))

def port_insert(cube_project_dir: str, pio_project_dir: str, lib_dir: str):
    local_path = join(pio_project_dir, "lib", lib_dir)
    port_c = join(local_path, "port.c")
    lines = file_2_lines(join(local_path, "main.c"))
    lines = line_insert_port("/* USER CODE BEGIN WHILE */", lines, "\tport_setup();")
    lines = line_insert_port("/* USER CODE END WHILE */", lines, "\t\tport_loop();")
    lines = line_insert_port('#include "main.h"', lines, f'#include "port.h"')
    lines_2_file(lines, port_c)

    glob_vars = line_extract("/* Private variables ---------------------------------------------------------*/",
                             "/* USER CODE BEGIN PV */",
                             lines)
    glob_vars = ["extern " + var for var in glob_vars if var.strip()]
    glob_vars = "".join(glob_vars)

    head = """
/**
\t******************************************************************************
\t THIS FILE IS AUTO-GENERATED BY cube2pio! DO NOT MODIFY!
\t See https://github.com/jesdev-io/cube2pio for more information.
\t* @file       port.h
\t* @author     jake-is-ESD-protected
\t* @brief      IDE port file which makes code generated by the STM32CubeIDE
\t*             accessible to PIO
\t******************************************************************************
\t* @attention
\t* The ported code is fully contained in this files's parent folder and not
\t* changed after the fact. This file replaces the `main.h` generated by the
\t* STM32CubeIDE.
\t******************************************************************************
*/
#ifndef __PORT_H
#define __PORT_H
#ifdef __cplusplus
extern "C" {
#endif
#include "stm32l4xx_hal.h"
#include "main.h"
/// @brief  Simpler user API for code before the main loop. Is always called after
///         every CubeMX function.
void port_setup(void);
/// @brief  Simpler user API for code inside the main loop. Is called on repeat in
///         the `while(1)` loop of the CubeMX code in `port.c`.
void port_loop(void);
/// @brief  export auto generated global variables from `main.c` (this part is also
///         auto generated)
"""
    tail = """
#ifdef __cplusplus
}
#endif
#endif /* __PORT_H */
"""
    with open(join(local_path, "port.h"), "w") as f:
        f.write(head.lstrip("\n") + glob_vars + tail)
    os.remove(join(local_path, "main.c"))

def main():
    parser = argparse.ArgumentParser(description="Convert STM32CubeIDE project to PlatformIO project.")
    parser.add_argument("-p", "--pio-project-dir", required=True, help="Full path to the PlatformIO project directory.")
    parser.add_argument("-c", "--cube-project-dir", required=True, help="Full path to the STM32CubeIDE project directory.")
    parser.add_argument("-l", "--lib-dir", default="port", help="Target directory inside PlatformIO's lib folder. Default: 'port'.")
    parser.add_argument("--use-freertos", action="store_true", help="Omit SVC_Handler, PendSV_Handler, and SysTick_Handler if using FreeRTOS.")
    args = parser.parse_args()

    port_init(args.pio_project_dir)
    port_copy(args.cube_project_dir, args.pio_project_dir, args.lib_dir, args.use_freertos)
    port_insert(args.cube_project_dir, args.pio_project_dir, args.lib_dir)

    print(f"Transfer STM32CubeIDE project {args.cube_project_dir} to PlatformIO project {args.pio_project_dir}/lib/{args.lib_dir}")
    

if __name__ == "__main__":
    main()